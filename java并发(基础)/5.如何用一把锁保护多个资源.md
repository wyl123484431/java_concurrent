#### 锁和资源的关联关系
* 受保护资源和锁之间合理的关联关系应该是N:1的关系
* 可以用一把锁保护多个资源,不可以用多把锁保护一个资源
#### 保护没有关联关系的多个资源
> ch5 Demo01

* 用同一把锁也可以，但是效率太低
* 用不同的锁对受保护资源进行精细化管理，能够提升性能，这种锁叫细粒度锁。
#### 保护有关联关系的多个资源
* 例如银行业务里面的转账操作，账户 A 减少 100 元，账户 B 增加 100 元。
> ch5 Demo02

![ZkvjCF.md.png](https://s2.ax1x.com/2019/06/24/ZkvjCF.md.png)

![ZAplUx.md.png](https://s2.ax1x.com/2019/06/24/ZAplUx.md.png)

**正确的使用锁的方式**
* 锁能覆盖所有受保护资源
> ch5 Demo03

> ch5 Demo04
* 串行化太高 不可行


* 用两把锁就实现了，转出账本一把，转入账本另一把。在 transfer() 方法内部，我们首先尝试锁定转出账户 this（先把转出账本拿到手），然后尝试锁定转入账户 target（再把转入账本拿到手），只有当两者都成功时，才执行转账操作
> ch5 Demo05

* 使用细粒度锁是有代价的，可能会导致死锁。

#### 死锁
* 一组互相竞争资源的线程因互相等待，导致"永久"阻塞的现象。

**死锁的放生条件**
1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
反过来分析，也就是说只要我们破坏其中一个，就可以成功避免死锁的发生。
#### 破坏一个就可以破坏死锁状态
1. 破坏占用且等待条件

![ZAJcqJ.md.png](https://s2.ax1x.com/2019/06/24/ZAJcqJ.md.png)

> ch5 Demo06

2. 破坏不可抢占条件
* Lock

3. 破坏循环等待条件

> ch5 Demo07

#### 总结
> “原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见

> 解决原子性问题，是要保证中间状态对外不可见。

> 用细粒度锁来锁定多个资源时，要注意死锁的问题。

> 评估一下操作成本，从中选择一个成本最低的方案。

#### 问题
* 4.破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环 while(actr.apply(this, target));这个方法，那它比 synchronized(Account.class) 有没有性能优势呢？