#### **1.单例问题**
> 出现在new 对象上

我们以为
1. 分配一块内存 M；
2. 在内存M上初始化SingLeton对象；
3. 然后在M的地址赋值给instance变量。

但优化后
1. 分配一块内存 M；
2. 然后在M的地址赋值给instance变量；
3. 在内存M上初始化SingLeton对象。

会出现空指针异常

![ZpxC1x.png](https://s2.ax1x.com/2019/06/22/ZpxC1x.png)

#### **2.那些办法让其他线程看见？**
1. 声明共享变量abc，并使用volatile关键字修饰abc
2. 声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。
3. A线程启动后，使用A.JOIN()方法来完成运行，后续线程再启动，则一定可以看到abc==3
#### **3.那些办法让其他线程看见？**
1. 不正确
2. 使用锁保护资源时，对资源的所有操作应该使用同一个锁，这样才能起到保护的作用。
3. 每个线程对资源的操作都是用的是各自的锁，不存在互斥和竞争的情况。
4. 这就相当于有一个房间，每个人过来都安装一个门，每个人都有自己门的钥匙，大家都可以随意出入这个房间。
5. 由于每个线程都可以随时进入方法，所以存在原子性问题；
6. 但是因为每次都有加锁和解锁的操作，unlock操作会使其他缓存的变量失效，需要重新从主内存中加载变量的值，所以可以解决可见性问题。
#### **4.while(!actr.apply(this, target));和synchronized(Account.class)的性能那个好？**
1. 这个要看具体的应用场景，不同应用场景它们的性能表现是不同的。在这个思考题里面，如果转账操作非常费时，那么前者的性能优势就显示出来了，因为前者允许 A->B、C->D 这种转账业务的并行。不同的并发场景用不同的方案，这是并发编程里面的一项基本原则；没有通吃的技术和方案，因为每种技术和方案都是优缺点和适用场景的。
#### **5.wait()和sleep方法都能让线程挂起一段时间，区别是什么？**
1. wait是Object类的，sleep是Thread的方法。
2. wait会释放所有锁而sleep不会释放锁。
3. wait只能用在同步块中，而sleep任何地方都可以。
#### **6.下面代码有什么问题？**

```
void addIfNotExist(Vector v, 
    Object o){
  if(!v.contains(o)) {
    v.add(o);
  }
}
```

```
void addIfNotExist(Vector v, 
    Object o){
synchronized(v) {
  if(!v.contains(o)) {
    v.add(o);
  }
}
}
```

