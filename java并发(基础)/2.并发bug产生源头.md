### CPU、内存、I/O
**描述三者之间的速度差异**
* CPU是天上一天，内存是地上一年
* 内存天上一天，I/O是地上十年
1. CPU 增加了缓存，以均衡与内存的速度差异；
2. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用
### 并发的源头问题(可见性、原子性、有序性)
**源头之一：CPU缓存导致的可见性问题**

* 单核时代

![ZpTZz4.png](https://s2.ax1x.com/2019/06/22/ZpTZz4.png)

单核时代，所有的线程都在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。

* 多核时代

![ZpTofU.png](https://s2.ax1x.com/2019/06/22/ZpTofU.png)
多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU。
> ch2 Demo01  实例

**源头之二：线程切换带来的原子性问题**

* 进程切换

[![ZpXfv8.md.png](https://s2.ax1x.com/2019/06/22/ZpXfv8.md.png)](https://imgchr.com/i/ZpXfv8)

早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。

* 线程切换

**count += 1 至少需要三条指令**
1. 首先，需要把变量 count 从内存加载到 CPU 的寄存器；
2. 之后，在寄存器中执行 +1 操作；
3. 最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）

[![ZpjJsS.md.png](https://s2.ax1x.com/2019/06/22/ZpjJsS.md.png)](https://imgchr.com/i/ZpjJsS)

**结果是1，不是我们期望的2**
> 我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。

> CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。

**源头之三：编译优化带来的有序性问题**
* 编译器为了优化性能，有时候会改变语句的先后顺序。"a=6;b=7;" 编译器优化后可能变成"b=7;a=6;"。

**java中经典案例(面试大佬 可能会问)**

* 双重锁创建单例 （懒汉式）
```
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}

```
* 1.有没有问题？ 如果有问题出现在里？




#### 总结
1. 缓存带来的可见性问题
2. 线程切换带来的原子性问题
3. 编译优化带来的有序性问题




